1. 在 Go 语言中 select 的用法
select语句有什么用途？
select 是 Go 中处理多通道（channel）操作的控制结构，核心用途包括：



多路复用（监听多个 channel）：

同时等待多个 channel 的读写操作，随机选择一个就绪的 case 执行（如 case <-ch1 或 case ch2 <- data），避免阻塞。

超时控制：

结合 time.After 实现超时机制，例如：select { case <-dataChan: ...; case <-time.After(3*time.Second): ... }。

非阻塞操作：

添加 default 分支实现非阻塞，当无 channel 就绪时立即执行 default（如用于检查 channel 状态）。

程序退出与错误处理：

监听退出信号 channel（如 <-doneChan），实现优雅终止。

检测 channel 关闭（如 case v, ok := <-ch 中 ok 标识状态）。
select 用于同时监听多个 channel，实现多路复用、超时控制等并发场景。
示例：
```go
ch1 := make(chan int)
ch2 := make(chan int)
go func() { ch1 <- 1 }()
go func() { ch2 <- 2 }()
select {
case v := <-ch1:
	fmt.Println("收到 ch1:", v)
case v := <-ch2:
	fmt.Println("收到 ch2:", v)
case <-time.After(time.Second):
	fmt.Println("超时")
}
```

2. Go 语言的断言
类型断言用于判断接口变量的具体类型。
示例：
```go
var i interface{} = "hello"
str, ok := i.(string)
if ok {
	fmt.Println("i 是 string 类型，值为：", str)
} else {
	fmt.Println("i 不是 string 类型")
}
```

3. Go 语言反射
反射用于在运行时动态获取变量的类型和值，常用 reflect 包。
go reflect 源码位于 src\reflect\下面，作为一个库独立存在。反射是基于接口实现的。



Go 反射有三大法则：



反射从接口映射到反射对象；

反射从反射对象映射到接口值；

只有值可以修改(settable)，才可以修改反射对象。



Go 反射基于上述三点实现。我们先从最核心的两个源文件入手 type.go 和 value.go.



type 用于获取当前值的类型。value 用于获取当前的值。

示例：
```go
import "reflect"
var x int = 10
t := reflect.TypeOf(x)
v := reflect.ValueOf(x)
fmt.Println("类型：", t)
fmt.Println("值：", v.Int())
```